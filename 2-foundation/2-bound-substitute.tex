\section{Bound substitution}\index{bound}
With everything said so far we seem no closer to unravelling the paradox 
of the trapped variable.  Following our rules for free substitution and 
Walrus naming, $K_c(x)\defeq c$ so 
\begin{align*}
    \tag{judgemental equality}
    (K_c(x))[c\leftrightarrows x] 
    & = c[c\leftrightarrows x]\\
    \tag{Free.match}
    & = x.
\end{align*}
The problem however was not in the symbols, but in what we interpreted them 
to mean.  Recall we tempted ourselves to treat both $I$ and $K$ as functions.
The paradox was that the identify \emph{function} should not be a  
constant \emph{function}.  Our sterile substitution simply shifted our notation 
of one function to the notation of the other leaving comparably equal strings 
but meaning vastly different things.  To put a finger right on the problem, 
it was our use of $f(x)\defeq...$ notation for functions that caused the problem.
Functions are more than merely naming some string.

Lets start by replacing the Walrus in our functions.
\begin{align*}
    I(x) & \includegraphics[width=0.5cm]{sheep.jpg} x & 
    K_c(x) & \includegraphics[width=0.5cm]{sheep.jpg} c.
\end{align*}
Now when we substitute we see the situation with fresh perspective.
We cannot seem to substitute on just the left-hand side of equals as 
there is no equals.  There are now long strings.  To substitute 
we need to involve the whole string.
\begin{align*}
    \bigl(I(x) \includegraphics[width=0.5cm]{sheep.jpg} x\bigr)[x\leftrightarrows \clubsuit] &
    \quad = \quad I(\clubsuit) \includegraphics[width=0.5cm]{sheep.jpg} \clubsuit\\
    \bigl(K_c(x) \includegraphics[width=0.5cm]{sheep.jpg} x\bigr)[x\leftrightarrows \clubsuit] &
    \quad = \quad K_c(\clubsuit) \includegraphics[width=0.5cm]{sheep.jpg} c\\
    \bigl(K_c(x) \includegraphics[width=0.5cm]{sheep.jpg} x\bigr)[c\leftrightarrows \clubsuit] &
    \quad = \quad K_{\clubsuit}(x) \includegraphics[width=0.5cm]{sheep.jpg} \clubsuit.
\end{align*}
Written this way we are not tempted to think of functions at all.
We are just as likely to be discussing which string gave our sheep the 
most clovers to eat.

Since Walrus did not lead us to an effective concept of functions, we need 
a new notation that does.  You already know it, just right $x\mapsto x$
for $I$ and $(x,c)\mapsto c$ for $K$.  In fact the way we thought of 
constant functions was as individuals for each $c$ so $x\mapsto c$ and 
$K$ was the function $c\mapsto (x\mapsto c)$ which for each $c$ built a 
function that was constantly returning $c$.  The idea was introduced 
by Alanzo Church.  Church used the notation $\lambda x.x$ and
$\lambda x.c$ because it fit in with other notation such as $\forall x.P$ and
$\exists x.Q$ and so on.  In his honor we describe these functions as 
``Churches'', just kidding, we call them \emph{lambdas} or  
\emph{anonymous functions}.


The variable set apart as the input is said to
be \emph{bound} to the function, it now has a specific role to play similar to
how $\forall x.P$  and $\exists x.Q$ bind $x$ into a special role as well.
Variables that do not have special roles are called \emph{free}.  Note that the
special role of $x$ in $x\mapsto M$ is limited to $M$.  We can say $M$ is the
\emph{scope}.  For this reason programs typically refer to bound variables a
\emph{local}.

Now let us extend substitution into lambdas.
\begin{definition}
Given strings $M<n$ and variables $x,y,\ldots$,
\begin{description}
    \item[Bound.match] $(x\mapsto M)[x\leftrightarrows N]\quad \defeq\quad (x\mapsto N)$
    \item[Bound.trapped]
    if $x$ is a free variable in $M$ and $y$ is a free variable in $N$ then 
    \[ 
        (y\mapsto M)[x\leftrightarrows N]
        \quad \defeq\quad (y'\mapsto (M[y\leftrightarrows y'])[x\leftrightarrows N])
    \]
    where 
    $y'$ is a variable distinct from any in $M$ and $N$ (which exists 
    as there are unbounded numbers of variables);

    \item[Bound.other] $(y\mapsto M)[x\leftrightarrows N]\defeq (y\mapsto M[x\leftrightarrows N])$.
\end{description}
\end{definition}

The first rule Bound.match may at first seem odd.  Aren't we trying to place $x$?
Yes but when we write $x\mapsto M$ we are declaring $x$ as a local variable.  
It is completely meaningless what it is called outside the scope of $M$.
It is the same thing we come to expect when we do things like this:
\begin{align*}
    \sum_{i=1}^{10} i^2 \qquad \prod_{i\in I}X_i 
\end{align*}
or in code 
\begin{center}
\begin{Pcode}[]
def sum(ns)= {
  x = 0
  for n in ns 
    x = x + n
  x  
}

x = [2,3,4]
sum(x)  // the x outside is not the x inside sum
\end{Pcode}
\end{center}