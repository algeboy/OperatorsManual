\section{Variables}

% So what is the root cause of our paradox of the trapped variable?
% The answer are bound (local) verses free variables.  In fact to 
% really appreciate this we need to decide what a variable is.

% The solution to these problems that we pursue was introduced by 
% Alanzo Church in the 1930's.  It is known as $\lambda$-calculus.
% It is a primitive conception of variables that can be used 
% as the foundation of more profound concepts like Set Theory. 
% Because it is so primitive it also works as a programming language
% and most of today's programming languages are built on a 
% $\lambda$-calculus.  It is also more flexible than Set Theory 
% and gives us ways to describe operations on large objects, like 
% all sets, or all groups, and etcetera.

% \begin{definition}
%     Fix an alphabet of constants and an alphabet of variables.
% \end{definition}



Why did something so basic as substition fail?  It has to do with variables
coming in two forms: free and bound.  If you program you might think of a global
verses local variable.  Yet unlike programming it requires that we 
think of variables as set aside symbols, not empty buckets into which we 
can store data.  In particular once you truly understand a variable
you will never regard it as proper to assign a variable a value.  That is,
$x\defeq 5$ does not make any sense.

We are about to define a calculus---a system of calculation and reasoning.
It is known today as $\lambda$-calculus and it was invented by Alanzo Church 
to explain how it is we can describe functions.  You may think this has been 
handled conveniently with sets: A function $f:A\to B$ is a subset $f$ of $A\times B$ where 
\[
    \forall a\in A\exists! b\in B.(a,b)\in f.
\]
It is a nice story, but if you look into the axioms of Set Theory they already
assume there are functions there to explain what sets are (look at the Axiom of
Specification or the Axiom of Replacement). So functions logically have to exist
before sets.  In fact we already saw two functions $I(x)=x$ and $K_c(x)=c$ that
could be explained with literally no concept of domain or codomain.  Later
within algebra we need this freedom to define higher-order structures such as
functors, which often cannot be explained with sets either.

\subsection{Pure $\lambda$-calculus}

To start out we designate an unbounded alphabet whose members we call ``variables''.
That is all it means to be a variable: you are a variable if you are in the alphabet of variables.  This alphabet 
can by anything, often it includes $x,y,z$ but the one condition is that 
this alphabet be unbounded.  You might think of this an an infinite alphabet but that starts to depend on notions of infinity from perhaps sets and becomes circular.
Rather all we insist is that we can always make a new variable different 
from the ones that are already present.  We might as well number the variables $x_1,x_2,\ldots$ and get on with real issues.

Let $L, M$ and $N$ be strings over the alphabet of variables
and fix a variable $x$.  We are about to describe the rules for substitution 
of $x$ by a $N$ in the string $M$.  We use the notation $M[x\leftrightarrows N]$ 
to indicate that we are swapping $N$ for $x$.  Historic 
options include $N/x$ but this runs a risk when used in algebra circles.
The Walrus $\defeq$ is used to define the symbols on the left, what is 
known as \emph{assignment} or \emph{judgemental equality}.  
\begin{enumerate}
    \item $x[x\leftrightarrows N]\defeq N$.
    \item $M[x\leftrightarrows N]\defeq M$ if $M$ is in the variables alphabet (and 
    because we already will have intercepted the case $M=x$ in the above case we know $M\neq x$).
    
    \item $(LM)[x\leftrightarrows N]\defeq L[x\leftrightarrows N]M[x\leftrightarrow N]$
\end{enumerate}
So far we have designated substitution in the obvious way: replace very 
symbol in a string by its replacement.  However these symbols do not as 
yet reach the level of functions because the are static, they are just 
apiece of data not a way to describe a change in data.

To define a function we need inputs and outputs, and that means to specify 
that some variables are the ones we want to replace.  Often 
we denote this by given a function a name, e.g.\ $I(x)=x$ gave the 
function the name $I$ and the proceeded to identify its variables.
Likewise $K_c(x)=c$ is a function of $x$, but not of $c$.  Finally the names are not important.  We are just as informed to write $x\mapsto x$ or $x\mapsto c$.  Church used the notation $\lambda x.x$ and $\lambda x.c$
because it fits in with other notation such as $\forall x.P$ and $\exists x.Q$ and so on.  In programs these are known as \emph{anonymous functions} or as $\lambda$'s.   The variable set apart as the input is said to be \emph{bound}
to the function, it now has a specific role to play similar to how $\forall x.P$  and $\exists x.Q$ bind $x$ into a special role as well.  Variables 
that do not have special roles are called \emph{free}.  Note that the special 
role of $x$ in $x\mapsto M$ is limited to $M$.  We can say $M$ is the \emph{scope}.  For this reason programs typically refer to bound variables a 
\emph{local}.

Now let us describe how we substitute into functions
\begin{enumerate}
    \item $(x\mapsto M)[x\leftrightarrows N]\defeq (x\mapsto N)$
    \item (Trapped Variable) 
    if $x$ is a free variable in $M$ and $y$ is a free variable in $N$ then 
    $(y\mapsto M)[x\leftrightarrows N]\defeq (y'\mapsto (M[y\leftrightarrows y'])[x\leftrightarrows N])$ where 
    $y'$ is a variable distinct from any in $M$ and $N$ (which exists 
    as there are unbounded numbers of variables);

    \item $(y\mapsto M)[x\leftrightarrows N]\defeq (y\mapsto M[x\leftrightarrows N])$.
\end{enumerate}

\subsection{Applied $\lambda$-calculus}
If all we allow in our reasoning is an alphabet of variables then we describe
the $\lambda$-calculus as \emph{pure}.  Meanwhile in real life we often are
willing to stake our understanding on several established concepts, for example
$0,1,2,3,\ldots$ or the number $\pi$, the color blue.  When we want to add this
to our study we create a \emph{separate} alphabet of constants.  A system with
constants is called an \emph{applied $\lambda$-calculus}.

\subsection{Curry-Feys Substitution}


\begin{definition}
    Given a variable alphabet and a constant alphabet, 
    an atom is is term from either alphabet and a 
    
\end{definition}
First things first: we should start by questioning even what it means to be a variable.



One sort will be constants, atoms like an alphabet, maybe digits, or a word or
special symbol. A second sort will be called variables. That its, variables are
symbols from special alphabet we call variables. This means that a variable can
never equal a constant, statements like $x=2$ are in strict sense nonsense.  But
hold off on that journey for a moment. Now having all these alphabets we can
form strings using the various letters. We could define arithmetic using digits
$0,\ldots, 9$, $+,-,\times,\div$ and some variables but lets simplify things to
true/false which is long enough to explore the idea.  We need to specify a
grammar of how allowed formulas can be made.  We basically separate the options
by $\mid$ (reads as ``or'') and use patterns to explain structures that are
built up recursively. So for Boolean (true/false) algebra we have true $\top$,
false $\bot$, and $\wedge$, or $\vee$, and not $\neg$ language might be defined
like this.
\newpage    
\begin{lstfloat}
\begin{lstlisting}[mathescape]
    <var>  ::= x | x_<int>
    <Bool> ::= $\top$ 
             | $\bot$ 
             | <var>
             | $\neg$ <Bool> 
             | <Bool> $\vee$ <Bool> 
             | <Bool> $\wedge$ <Bool>.
\end{lstlisting}
\end{lstfloat}

To get started lets return to our use of a grammar.  The diagram we had 
was a tree, what is known as a \emph{parse tree}.  It is the same thing you 
do when you diagram a sentence in grammar school, only with English you can 
sometimes get cycles.  That we got a tree is owed to the fact that the grammars 
for mathematics are basic and gentle, what Chompsky calls \emph{context-free} grammars.

This situation comes about because of two flavors of variables: free and bound,
also called local.  A variable can be bound in many ways, for example 
$\forall x$ binds $x$ to $\forall$, same with $\exists x$.  The binding tells 
us that even if we are using $x$ somewhere else, form this point till 
the end of the block we are simply recycling the name $x$, but its meaning 
is now controlled by the start of the binding.  The binding in the 
substitution examples above is hidden by notation but it is third form 
known as $\lambda$-binding, such as $x\mapsto x+2$ (historically 
$\lambda x.(x+2)$ which is where the name comes from).  This says that 
$x$'s role is to serve as the variable in describing a function.
In the constant function $c\mapsto K_c$ or rather $c\mapsto (x\mapsto c)$.
Likewise $\sqrt{n}{u}$ means $n\mapsto (u\mapsto \sqrt[n]{u})$
Now the point is that a local variable is just reusing a symbol it has 
no visibility outside.

Why did something so basic fail?  It has to do with variables coming in 
two forms: free and bound.  If you program you might think of a global 
verses local variable.  First things first: variables?
First sort out the data.  One sort will be constants, atoms like an alphabet,
maybe digits, or a word or special symbol. A second sort will be called variables.
That its, variables are symbols from special alphabet we call variables.
This means that a variable can never equal a constant, statements like $x=2$ 
are in strict sense nonsense.  But hold off on that journey for a moment.
Now having all these alphabets we can form strings using the various letters.
We could define arithmetic using digits $0,\ldots, 9$, $+,-,\times,\div$ and some 
variables but lets simplify things to true/false which is long enough to 
explore the idea.  We need to specify a grammar of how allowed formulas can 
be made.  We basically separate the options by $\mid$ (reads as ``or'')
and use patterns to explain structures that are built up recursively.
So for Boolean (true/false) algebra we have true $\top$, false $\bot$, 
and $\wedge$, or $\vee$, and not $\neg$ language might be defined like this.
\newpage    
\begin{lstfloat}
\begin{lstlisting}[mathescape]
    <var>  ::= x | x_<int>
    <Bool> ::= $\top$ 
             | $\bot$ 
             | <var>
             | $\neg$ <Bool> 
             | <Bool> $\vee$ <Bool> 
             | <Bool> $\wedge$ <Bool>.
\end{lstlisting}
\end{lstfloat}




Before leaving a word on \emph{sorts}.
Refine this as you like. For instance, one sort $a,b,c,\ldots,m,n,\dots, x,y,z,
x_1,x_2,\ldots$ for numbers, a sort $+,-,\times, [\ldots]_{\ell},\ldots$ for
operators, $\cong, \equiv, \ldots$ for equality.  You decide, it is a made up 
language.



  Formulas are strings over these alphabets.  Each of these has a 
a grammar and a handy notation is 
to separate options by $\mid$ which reads as \emph{or}.  For example, 
a true $\top$, false $\bot$, and $\wedge$, or $\vee$, and not $\neg$ language might be defined like this.
\newpage    
\begin{lstfloat}
\begin{lstlisting}[mathescape]
    <var>  ::= x | x_<int>
    <Bool> ::= $\top$ 
            | $\bot$ 
            | <var>
            | $\neg$ <Bool> 
            | <Bool> $\vee$ <Bool> 
            | <Bool> $\wedge$ <Bool>.
\end{lstlisting}
\end{lstfloat}

So $x$ is a boolean, as is $\top$ and $\neg x\wedge x_3$.  Math languages assume 
also the symbols for parenthesis.

of variables for numbers will be $m,n,\ldots,
x,y,\ldots$ whereas a separate sort of variable is used for operations, such as
$+,-,\times,\ldots$, and still another $A,B,C,\ldots$ for sets and so forth.
Sorts used in this way have formal meaning in logic and I mention that because 
you will come across it in examples of formal methods---the growing field 
blending the idea of proving theorems with proving programs, what we will 
need to make safe self-driving cars and video games that you can't cheat.

Starting with a string $M$ with symbols of various sorts, the task is to 
substitution variable $x$ in by another string $N$.  If there is only one 
variable around you may think of this as $M(N)$.   Since $M$ may have many 
variables let us be specific:
\begin{align*}
    M[x\defeq N]
\end{align*}
To see how to do this lets break the down th process of making $M$.
For example we might be in context of a simple calculator.  So our constants 
are the digits $0,1,\ldots,9$, and we have also $+,-,\times,\div$.
Variables we call $x,y,z$ and if we need more $x_n$ where is a sequence 
of digits will do.


We can start out small with two sorts of data.  One 
sort are atomic symbols, digits, an alphabet or some other meaning 
of a constant.  The second sort are variables.  Then we formula 
$M$ is either an atom $a$, a variable $x$, or the concatenation 
of two formulas $K$ and $L$.  There is a popular notation for this 
is to separate each case by the stroke $\mid$ which reads as ``or''.
\begin{lstlisting}[language=Hidris,mathescape]
    F[X] = 0 | 1 | ... | 9 | + | -
         | x
         | <F[X]> cat <F[X]>
\end{lstlisting}

So if our atoms are $\clubsuit,\heartsuit, \spadesuit,\diamondsuit$
and 
\begin{lstlisting}[language=Hidris,mathescape]
    F[X] = a:A 
         | x:X
         | K:F[X] cat L:F[X]
\end{lstlisting}

\begin{lstlisting}[language=Hidris,mathescape]

    M[x:=N] =
        match M with 
                a:A $\Rightarrow$ a
                y:X $\Rightarrow$ if x=y then N else y
            K cat L $\Rightarrow$ K[x:=N] cat L[x:=N]
             y $\mapsto$ L $\Rightarrow$ if x=y then y $\mapsto$ L 
                                         else if x free in L 
    \end{lstlisting}
    

\begin{lstlisting}[language=Sava,mathescape]
F[X] = a:A 
     | x:X
     | M:F[X] cat N:F[X]
     | x:X $\mapsto$ M:F[X]

M[x:=N] =
    match M with 
            a:A $\Rightarrow$ a
            y:X $\Rightarrow$ if x=y then N else y
        K cat L $\Rightarrow$ K[x:=N] cat L[x:=N]
         y $\mapsto$ L $\Rightarrow$ if x=y then y $\mapsto$ L 
                                     else if x free in L 
\end{lstlisting}


