\chapter{Natural numbers as grammar}
\index{natural numbers|(}
Math in early history (early childhood) is counting.  Count 
pebbles or beads and give the patterns names
\begin{center}
    $0\defeq$ \underline{\hspace{5mm}}, 
    $1\defeq$ \StrokeOne,
    $2\defeq$ \StrokeTwo,
    $3\defeq$ \StrokeThree,
    $4\defeq$ \StrokeFour,
    $5\defeq$ \StrokeFive,...
\end{center}
One hypothesis for the symbol
``0'' is that it looks like the shape left by removing the last pebble from
a sand table leaving behind no pebbles.

\index{Peano}
It struck Giuseppe Peano in the early 1900's that tallies would be easier to get
right mathematically than digits. With the following two rules Peano introduced
the natural numbers to the formalism of math.
\begin{quote}
    \textit{
    $N_0$ vale ``numero'', et es nomen commune de 0,1,2, etc.\\
    $0$ $\to$  ``zero''\\
    $+$ $\to$ ``plus''.  Si $a$ es numero, $a+$ indica ``numero sequente $a$''.
    }
\end{quote}
% It is fitting that the Italian is in italics.
(See G. Peano \emph{Formulaire de mathematiques.~I-V}, p.27.)
Replacing $+$ with \StrokeOne ~(and equating \StrokeFive$\defeq$\StrokeFour~\StrokeOne),
Peano's model of numbers is simply the grammar of tallies.

Today notation has evolved.  These numbers are now almost always designated as
\emph{natural numbers} and denoted $\mathbb{N}$.  Instead of $a+$ we now often
write $S~k$  or $S(k)$ calling it the ``successor'' to the natural number $k$.  
Programming however has held closer to the original with notation like 
\code{i++} and \code{++i}.

\index{tag}\index{token}\index{\code{<Token>}}\index{\code{::=}}\index{Walrus}
We mentioned Peano was merely recording a grammar.  Today we write grammars with
list of rules, called \emph{production rules}.  Some rules are to specify what
makes up the alphabet of symbols in our grammar.  For Peano, $0$ and $S$ are the
complete alphabet.  So we may write either $0$ on its own, or we may pre-pend
the symbol $S$ to any existing natural number.  Each rule is given a name called
a \emph{token} (or \emph{tag}) and denoted \code{<Name>}. Since the Walrus
$\defeq$ is our assignment of variables (more on this later), we use the
``astonished Walrus'' $::=$ as assignment of production rules.   Taken together
the grammar is the following, shown next to the childhood grammar for tallies.
\begin{center}
\begin{minipage}{0.4\textwidth}
\begin{Gcode}[]
<Nat> ::= 0 
<Nat> ::= S <Nat>
\end{Gcode}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\begin{Gcode}[]
<Tally> ::=  
<Tally> ::= | <Tally>
\end{Gcode}
\end{minipage}
\end{center}
In the first rule we are told \code{0} is a natural number, denoted
\code{0:Nat}, just as any whitespace can start a tally. We say that the natural
number grammar \emph{accepts} \code{0} because it matched some production rule,
and the Tally grammar accepts whitespace, usually denoted $\epsilon$.  In the
second rule if we encounter an \code{S} it must be followed by an \emph{already
known} natural number.  So \code{S0:Nat} but \code{0S} would not be accepted as
it is not found as a production rule.  Going forward we use $\mathbb{N}$ 
for \code{Nat} and the usual name $0,1\defeq S0, 2\defeq SS0,\ldots$ as is common.
We retain the notation $n:\mathbb{N}$, instead of $n\in \mathbb{N}$, on account 
of the view that we need natural numbers well before we have a notion of Set Theory.

\index{language}
\begin{definition}
    The words (also called strings) of letters accepted by a grammar is called
    the grammar's \emph{language}.
\end{definition}

\begin{example}
The natural numbers are the language of Peano's grammar, that is, the language of tallies.
\end{example}

The significance of the ``already known'' clause of the rules is to prevent ambiguity 
with terms like $n=$\code{SSS....} where the \code{S} continue forever.
For if we remove one \code{S} form this $n$, the string is unchanged (thanks to 
the infinite number of $S$'s).  Since we are engaged in deciding if $n$ is a natural number and its substring 
is $n$, it is not of the form \code{S k} for \code{k:Nat}.  Hence the grammar 
rejects such an $n$.  Grammar's like these are called \emph{primitive recursive}
meaning that the recursion can only depend backwards 
in history.

\begin{definition}
    A production rule that appears more than once is called \emph{inductive}.
\end{definition}

An accepted short hand for inductive productions rules is to name it once 
and separate the cases by $\mid$, for instance,
\begin{center}
\code{<Nat>::= 0 | S <Nat>} \\
\begin{Gcode}[]
<Nat> ::= 0 
        | S <Nat>
\end{Gcode}
\end{center}
Because of this notation for inductive types I will hence forth limit my use of tallies
to avoid confusion, but I stress that a simplicity often emerges from thinking 
of tallies instead of successors.
    

\begin{remark}{}
    Some argue that $0$ does not ``belong in'' $\mathbb{N}$ because 
    we begin counting at $1$.  Others argue that Peano's postulates
    clarify that $0$ is a natural number and begin counting from there.\\

    Both perspectives miss the point.  Peano is telling us that $\mathbb{N}$
    is not a set of numbers at all.  Instead it is two operators:
    \begin{itemize}
        \item $0$ clears the slate, preparing for a new count.
        \item $S$ successor advances the count.
    \end{itemize}
    So indeed $0$ is required at the start \emph{and} the first count will be $1$.
    The set of numbers created is immaterial.  Its the operations we need for counting.
\end{remark}

