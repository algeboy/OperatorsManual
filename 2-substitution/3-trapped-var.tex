
\section{Paradox of the Trapped Variable.}

To avoid trapped variables I use the rules set out by Curry-Feys.
First you need a grammar.  Keeping to context free and learning by example

Why did something so basic fail?  It has to do with variables coming in 
two forms: free and bound.  If you program you might think of a global 
verses local variable.  First things first: variables?
First sort out the data.  One sort will be constants, atoms like an alphabet,
maybe digits, or a word or special symbol. A second sort will be called variables.
That its, variables are symbols from special alphabet we call variables.
This means that a variable can never equal a constant, statements like $x=2$ 
are in strict sense nonsense.  But hold off on that journey for a moment.
Now having all these alphabets we can form strings using the various letters.
We could define arithmetic using digits $0,\ldots, 9$, $+,-,\times,\div$ and some 
variables but lets simplify things to true/false which is long enough to 
explore the idea.  We need to specify a grammar of how allowed formulas can 
be made.  We basically separate the options by $\mid$ (reads as ``or'')
and use patterns to explain structures that are built up recursively.
So for Boolean (true/false) algebra we have true $\top$, false $\bot$, 
and $\wedge$, or $\vee$, and not $\neg$ language might be defined like this.
\newpage    
\begin{lstfloat}
\begin{lstlisting}[mathescape]
    <var>  ::= x | x_<int>
    <Bool> ::= $\top$ 
             | $\bot$ 
             | <var>
             | $\neg$ <Bool> 
             | <Bool> $\vee$ <Bool> 
             | <Bool> $\wedge$ <Bool>.
\end{lstlisting}
\end{lstfloat}

To get started lets return to our use of a grammar.  The diagram we had 
was a tree, what is known as a \emph{parse tree}.  It is the same thing you 
do when you diagram a sentence in grammar school, only with English you can 
sometimes get cycles.  That we got a tree is owed to the fact that the grammars 
for mathematics are basic and gentle, what Chompsky calls \emph{context-free} grammars.

This situation comes about because of two flavors of variables: free and bound,
also called local.  A variable can be bound in many ways, for example 
$\forall x$ binds $x$ to $\forall$, same with $\exists x$.  The binding tells 
us that even if we are using $x$ somewhere else, form this point till 
the end of the block we are simply recycling the name $x$, but its meaning 
is now controlled by the start of the binding.  The binding in the 
substitution examples above is hidden by notation but it is third form 
known as $\lambda$-binding, such as $x\mapsto x+2$ (historically 
$\lambda x.(x+2)$ which is where the name comes from).  This says that 
$x$'s role is to serve as the variable in describing a function.
In the constant function $c\mapsto K_c$ or rather $c\mapsto (x\mapsto c)$.
Likewise $\sqrt{n}{u}$ means $n\mapsto (u\mapsto \sqrt[n]{u})$
Now the point is that a local variable is just reusing a symbol it has 
no visibility outside.

Why did something so basic fail?  It has to do with variables coming in 
two forms: free and bound.  If you program you might think of a global 
verses local variable.  First things first: variables?
First sort out the data.  One sort will be constants, atoms like an alphabet,
maybe digits, or a word or special symbol. A second sort will be called variables.
That its, variables are symbols from special alphabet we call variables.
This means that a variable can never equal a constant, statements like $x=2$ 
are in strict sense nonsense.  But hold off on that journey for a moment.
Now having all these alphabets we can form strings using the various letters.
We could define arithmetic using digits $0,\ldots, 9$, $+,-,\times,\div$ and some 
variables but lets simplify things to true/false which is long enough to 
explore the idea.  We need to specify a grammar of how allowed formulas can 
be made.  We basically separate the options by $\mid$ (reads as ``or'')
and use patterns to explain structures that are built up recursively.
So for Boolean (true/false) algebra we have true $\top$, false $\bot$, 
and $\wedge$, or $\vee$, and not $\neg$ language might be defined like this.
\newpage    
\begin{lstfloat}
\begin{lstlisting}[mathescape]
    <var>  ::= x | x_<int>
    <Bool> ::= $\top$ 
             | $\bot$ 
             | <var>
             | $\neg$ <Bool> 
             | <Bool> $\vee$ <Bool> 
             | <Bool> $\wedge$ <Bool>.
\end{lstlisting}
\end{lstfloat}




Before leaving a word on \emph{sorts}.
Refine this as you like. For instance, one sort $a,b,c,\ldots,m,n,\dots, x,y,z,
x_1,x_2,\ldots$ for numbers, a sort $+,-,\times, [\ldots]_{\ell},\ldots$ for
operators, $\cong, \equiv, \ldots$ for equality.  You decide, it is a made up 
language.



  Formulas are strings over these alphabets.  Each of these has a 
a grammar and a handy notation is 
to separate options by $\mid$ which reads as \emph{or}.  For example, 
a true $\top$, false $\bot$, and $\wedge$, or $\vee$, and not $\neg$ language might be defined like this.
\newpage    
\begin{lstfloat}
\begin{lstlisting}[mathescape]
    <var>  ::= x | x_<int>
    <Bool> ::= $\top$ 
            | $\bot$ 
            | <var>
            | $\neg$ <Bool> 
            | <Bool> $\vee$ <Bool> 
            | <Bool> $\wedge$ <Bool>.
\end{lstlisting}
\end{lstfloat}

So $x$ is a boolean, as is $\top$ and $\neg x\wedge x_3$.  Math languages assume 
also the symbols for parenthesis.

of variables for numbers will be $m,n,\ldots,
x,y,\ldots$ whereas a separate sort of variable is used for operations, such as
$+,-,\times,\ldots$, and still another $A,B,C,\ldots$ for sets and so forth.
Sorts used in this way have formal meaning in logic and I mention that because 
you will come across it in examples of formal methods---the growing field 
blending the idea of proving theorems with proving programs, what we will 
need to make safe self-driving cars and video games that you can't cheat.

Starting with a string $M$ with symbols of various sorts, the task is to 
substitution variable $x$ in by another string $N$.  If there is only one 
variable around you may think of this as $M(N)$.   Since $M$ may have many 
variables let us be specific:
\begin{align*}
    M[x\defeq N]
\end{align*}
To see how to do this lets break the down th process of making $M$.
For example we might be in context of a simple calculator.  So our constants 
are the digits $0,1,\ldots,9$, and we have also $+,-,\times,\div$.
Variables we call $x,y,z$ and if we need more $x_n$ where is a sequence 
of digits will do.


We can start out small with two sorts of data.  One 
sort are atomic symbols, digits, an alphabet or some other meaning 
of a constant.  The second sort are variables.  Then we formula 
$M$ is either an atom $a$, a variable $x$, or the concatenation 
of two formulas $K$ and $L$.  There is a popular notation for this 
is to separate each case by the stroke $\mid$ which reads as ``or''.
\begin{lstlisting}[language=Hidris,mathescape]
    F[X] = 0 | 1 | ... | 9 | + | -
         | x
         | <F[X]> cat <F[X]>
\end{lstlisting}

So if our atoms are $\clubsuit,\heartsuit, \spadesuit,\diamondsuit$
and 
\begin{lstlisting}[language=Hidris,mathescape]
    F[X] = a:A 
         | x:X
         | K:F[X] cat L:F[X]
\end{lstlisting}

\begin{lstlisting}[language=Hidris,mathescape]

    M[x:=N] =
        match M with 
                a:A $\Rightarrow$ a
                y:X $\Rightarrow$ if x=y then N else y
            K cat L $\Rightarrow$ K[x:=N] cat L[x:=N]
             y $\mapsto$ L $\Rightarrow$ if x=y then y $\mapsto$ L 
                                         else if x free in L 
    \end{lstlisting}
    

\begin{lstlisting}[language=Sava,mathescape]
F[X] = a:A 
     | x:X
     | M:F[X] cat N:F[X]
     | x:X $\mapsto$ M:F[X]

M[x:=N] =
    match M with 
            a:A $\Rightarrow$ a
            y:X $\Rightarrow$ if x=y then N else y
        K cat L $\Rightarrow$ K[x:=N] cat L[x:=N]
         y $\mapsto$ L $\Rightarrow$ if x=y then y $\mapsto$ L 
                                     else if x free in L 
\end{lstlisting}


