\section{Logical operators}

We can summarize this accomplishment in two logical rules, but first allow 
me to digress to explain three crucial differences in the logic of going from 
one list of facts to another.

\subsection{Meta language}

In fact, the notation \code{<Name> ::= ...} is evolving a grammar of its own
in a format known as \emph{Backus-Naur Form (BNF)}.  In different notation the 
idea was already present in Panini's explanations of the sanskrit language.


\subsection{Three meanings of ``forward proof''}
 A sentence that may contain variables which when 
assigned can have a truth value is called a \emph{predicate}.\footnote{Historically it 
is also known as a \emph{proposition} but that word has so often been used exclusively 
for true statements that it now offers more confusion than then the completely uninformative word ``predicate''.}  
For example 
\begin{center}
    $P(n):\equiv$ ``$n$ is even''.
\end{center}
Witness $P(2)=\top$ (true), that is ``$2$ is even''.  
Notice $P(5)=\bot$ (is false).  In all cases these are truth values
so $P(n)$ is a predicate.  Notice truth values may be unknowable.
At present for example, taking 
\[ 
    f(n) =\begin{cases} n/2 & 2\mid n\\ 3n+1 & 2\not\mid n \end{cases}
\]
we can ask $P:\equiv \forall n.\liminf_{i\to \infty}f^i(n)=1$.
This could be true or false, but no one yet knows.  It is the Collatz conjecture.
Some wonder if it belongs to a class of statements that can never be known
as true or false.  If that is the case it would come down to an axiom 
(the Law of Excluded Middle if you use it) to assign it one of those choice.
However, logic is just as capable of using ``unknowable'' as a truth value.

Suppose that $P$ is a list of predicates 
and $q$ is a single predicate.  Then there are at least three possible 
ways that we might think of going from $P$ to $q$.
\begin{description}
    \item[Derives] write $P\vdash q$ when there is a proof from $P$ to $q$.
    (Formally: a proof is a rooted tree with root $q$, leaves either from $P$ or axioms, 
    and all internal nodes labeled by a logical operation.  In computer science 
    these are known as \emph{fan-in circuits}.)
    
    \item[Entails] write $P\vDash q$ when for every assignment of variables that makes 
    $P$ true, that assignment of variables makes $q$ true.

    \item[Implies] $p\Rightarrow q$ is merely a binary operator that takes
    predicates $p$ and $q$ and outputs a new predicate denoted $p\Rightarrow q$.
    So $P\Rightarrow q$ can take on a value of $\top$ but we cannot say 
    that it is true, it is just a predicate that it may be true.
\end{description}
A mathematician is prone to confuse these three and with good reason.
The first leads to the second, and the second leads to the third \emph{being true},
in symbols
\begin{itemize}
    \item $(p\vdash q)\vdash (P\vdash q)$.
    \item $\displaystyle (p\vDash q)\vdash \left(\vdash \left(\bigwedge_{p\in P} p\right) \Rightarrow q\right)$.
\end{itemize}
Notice $\vdash X$ means it takes nothing to prove $X$, in other words,
this is a fancy way to infer that $X$ is true.  

\begin{remark}
    So is it strictly speaking meaningful to write something like the 
    following? 
    \begin{quote}
        \textbf{Theorem.} $n=2k\Rightarrow \gcd(k,n+2)=2$.
        \hfill{\color{BrickRed} (Meaningless)}
    \end{quote}
    On the one hand this is not a statement of fact any more than 
    to say ``$n$ is even.''  To write $p\Rightarrow q$ is to give 
    a predict, not to argue that it is true.  A proper statement 
    might be 
    \begin{quote}
        \textbf{Theorem.} $n=2k\vdash \gcd(k,n+2)=2$.
        \hfill{\color{BrickRed} (Formally Correct)}
    \end{quote}

    On the other hand, the label ``Theorem'' could be tasked with the 
    role of decorating the predicate with an air of validity, as if 
    to implicitly tack on the ending ``...is true'' in invisible red ink:
    \begin{quote}
        \textbf{Theorem.} ``$n=2k\Rightarrow \gcd(k,n+2)=2$'' {\color{BrickRed} is true.}
    \end{quote}
    Yet, proponents of such fix should ponder if they really want to say
    Theorem. ``$n=2k$ is even'' is true.

    \noindent\rule{\textwidth}{1pt}
    Perhaps a solution worth considering is that in mathematics we 
    despense with the notation we do not entirely understand.  We may write 
    \begin{quote}
        \textbf{Theorem.} If $P$  then $q$.
        \hfill{\color{BrickRed} (Acceptable)}
    \end{quote}
\end{remark}
Finally, be mindful that G\"odel proved that the converse is false.  There
examples where we can write $P\vDash q$ but not $P\vdash q$.   This is sometimes
misrepresented as saying ``there are theorems which are true but cannot be
proved.'' That however looses the subtlety behind his claim by using the
vagueness of the word ``theorem'' to simultaneously mean both $\vDash$ and
$\vdash$.  More accurate reading would be that it may be impossible to find
counter-examples where $P$ is true and $q$ is false. Notice I did not say
``there are no counter-examples'' just that there is no process to find a
counter-example.  As everyone knows failure find counter-examples is not itself
a proof of anything. This leads one simply to surmise either by decree of axioms 
that such a situation should now count as a new form of proof, or to accept that 
some situations like this exist.

If you want to truly explore $\Rightarrow$ as an operator explore Heyting Algebras.


\subsection{A closer look}
Perhaps the most convincing way to see that we are creating 
data is to run this process all the way down to what a machine 
must do and witness that somewhere the computer must somewhere 
as for storage space.  We will do this 
in stages as the bottom is a mighty long fall.

A first step might be to convert the cases into a sequence 
of two functions which both make appropriate changes to 
some internal value.  This might look like this:
\begin{center}
\begin{lstlisting}[language=Java]
class NaturalNumber {
    int value // Internal computer storage
    Zero() {value=0} // zero out the memory
    Next(k:NaturalNumber){value=k+1}
}
z = new Zero()  // make a 0
two = new Next(new Next(z)) // make a 2
\end{lstlisting}
\end{center}

Grouping this under a single data type `NaturalNumber'
is mostly just for us not to get confused.  When we 
zoom in closer we find that the computer splits 
this apart, making the storage space separate from the 
functions that use it.  Here is a lower level take
and a realization that indeed both introductions (constructors)
need to ask for some storage, they do not really know 
how much, the computer calculates that for them.
\begin{center}
\begin{lstlisting}[language=C]
struct Nat { int length, uint8[] digits }
Nat NaturalNumber_Zero() { 
    memory = malloc(Nat) // allocate memory
    memory.length = 1
    memory.value[0] = 0
    return memory 
}
Nat NaturalNumber_Next(k:Nat) {
    memory = malloc(Nat) // allocate memory
    if k.digits[k.length-1] != 0 then
        memory.length = length +1
    
    memory.digits = k.digits +1
    return memory 
}
\end{lstlisting}
\end{center}

If we zoom in even further we see this `malloc' command eventually 
translate into asking for actual memory in the computer.  Here is a
simplified take that assumes the length is fixed at 9 bytes, that is 
the maximum value reached is $2^{128}$, it would take all the computers 
in the world to tally from $0$ to $2^{128}$ in your lifetime so 
this is a safe limit.
\begin{center}
\begin{lstlisting}[language={ [x86masm]Assembler}]
%macro NaturalNumber_Zero 0
    mov param1, 0x0009      ; move 4 into first parameter
    call malloc            ; storage of size param1 (=9)
    mov store, 0x0000      ; mov 0 into the storage
    ret 

%macro NaturalNumber_Next 1
    int  temp
    mov  temp, param1     ; make a copy of first input
    mov param1, 0x0009      
    call malloc          ; storage of size 9
    mov  store, temp     ; move input to storage
    inc  store           ; increment storage 
    ret 
\end{lstlisting}
\end{center}

As this snippet reveals this program comes to a physical limit 
once we exceed the internal storage capabilities of integers in the
system.  We can fix this but the spirit of the programs above 
is to separate the need to understand the computer deeply and see the 
overall behavior.
